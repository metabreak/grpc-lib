{"version":3,"file":"grpc-handler.js","sourceRoot":"","sources":["../src/grpc-handler.ts"],"names":[],"mappings":";;;AAAA,sEAKuC;AAUvC,MAAa,WAAW;IACd,YAAY,CAAoB;IAExC,YAAY,sBAA2D;QACrE,IAAI,CAAC,YAAY,GAAG,CAAC,sBAAsB;YACzC,CAAC,CAAC,EAAE;YACJ,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,sBAAsB,CAAC;gBACvC,CAAC,CAAC,sBAAsB;gBACxB,CAAC,CAAC,CAAC,sBAAsB,CAAC,CAAC;IAC/B,CAAC;IAQD,MAAM,CACJ,OAA0B;QAE1B,MAAM,YAAY,GAAG,CAAC,IAAI,CAAC,YAAY,IAAI,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC;QACvD,MAAM,WAAW,GAAG,YAAY,CAAC,KAAK,EAAE,CAAC;QAEzC,IAAI,WAAW,EAAE;YACf,OAAO,WAAW,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC;SACtE;QAED,IAAI,OAAO,CAAC,IAAI,KAAK,iCAAY,CAAC,KAAK,EAAE;YACvC,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CACzB,OAAO,CAAC,IAAI,EACZ,OAAO,CAAC,WAAW,EACnB,OAAO,CAAC,eAAe,EACvB,OAAO,CAAC,YAAY,EACpB,OAAO,CAAC,aAAa,CACtB,CAAC;SACH;QAED,OAAO,OAAO,CAAC,MAAM,CAAC,YAAY,CAChC,OAAO,CAAC,IAAI,EACZ,OAAO,CAAC,WAAW,EACnB,OAAO,CAAC,eAAe,EACvB,OAAO,CAAC,YAAY,EACpB,OAAO,CAAC,aAAa,CACtB,CAAC;IACJ,CAAC;CACF;AA7CD,kCA6CC","sourcesContent":["import {\n  GrpcCallType,\n  GrpcEvent,\n  GrpcMessage,\n  GrpcRequest,\n} from '@metabreak/grpc-worker-common';\nimport { Observable } from 'rxjs';\nimport { GrpcInterceptor } from './grpc-interceptor';\n\n/**\n * Core gRPC transport class. Implements creation and binding of RPCs to the clients.\n * There is a root GrpcHandler that handles all initial requests;\n * however for every interception a new instance of GrpcHandler is created and passed to the interceptor\n */\n\nexport class GrpcHandler {\n  private interceptors: GrpcInterceptor[];\n\n  constructor(configuredInterceptors: GrpcInterceptor | GrpcInterceptor[]) {\n    this.interceptors = !configuredInterceptors\n      ? []\n      : Array.isArray(configuredInterceptors)\n      ? configuredInterceptors\n      : [configuredInterceptors];\n  }\n\n  /**\n   * Handles the gRPC request passing it through the interceptors array\n   * Recursively calls all interceptors with a new instance of the GrpcHandler\n   * @param request a GrpcRequest to execute\n   * @returns Observable of events returned by the GrpcClient implementation\n   */\n  handle<Q extends GrpcMessage, S extends GrpcMessage>(\n    request: GrpcRequest<Q, S>,\n  ): Observable<GrpcEvent<S>> {\n    const interceptors = (this.interceptors || []).slice();\n    const interceptor = interceptors.shift();\n\n    if (interceptor) {\n      return interceptor.intercept(request, new GrpcHandler(interceptors));\n    }\n\n    if (request.type === GrpcCallType.unary) {\n      return request.client.unary(\n        request.path,\n        request.requestData,\n        request.requestMetadata,\n        request.requestClass,\n        request.responseClass,\n      );\n    }\n\n    return request.client.serverStream(\n      request.path,\n      request.requestData,\n      request.requestMetadata,\n      request.requestClass,\n      request.responseClass,\n    );\n  }\n}\n"]}